!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADD_EXP_TEST	pqunit.cc	1292;"	d	file:
ADD_OTHER_TEST	pqunit.cc	1293;"	d	file:
ADD_TEST	pqunit.cc	1291;"	d	file:
Allocator	pqmemory.hh	/^class Allocator {$/;"	c	namespace:pq
Datum	pqdatum.hh	/^class Datum : public pequod_set_base_hook, public KeyHook<Datum> {$/;"	c	namespace:pq
Datum	pqdatum.hh	/^inline Datum::Datum(Str key)$/;"	f	class:pq::Datum
Datum	pqdatum.hh	/^inline Datum::Datum(Str key, const Sink* owner)$/;"	f	class:pq::Datum
Datum	pqdatum.hh	/^inline Datum::Datum(Str key, const String& value)$/;"	f	class:pq::Datum
DatumDispose	pqdatum.hh	/^struct DatumDispose {$/;"	s	namespace:pq
DefaultPartitioner	pqpartition.cc	/^DefaultPartitioner::DefaultPartitioner(uint32_t nservers)$/;"	f	class:pq::__anon11::DefaultPartitioner
DefaultPartitioner	pqpartition.cc	/^class DefaultPartitioner : public Partitioner {$/;"	c	namespace:pq::__anon11	file:
Evictable	pqsink.cc	/^Evictable::Evictable() : evicted_(false), last_access_(0) {$/;"	f	class:pq::Evictable
Evictable	pqsink.hh	/^class Evictable : public lru_hook {$/;"	c	namespace:pq
HackerNewsPartitioner	pqpartition.cc	/^HackerNewsPartitioner::HackerNewsPartitioner(uint32_t nservers, uint32_t nbacking,$/;"	f	class:pq::__anon11::HackerNewsPartitioner
HackerNewsPartitioner	pqpartition.cc	/^class HackerNewsPartitioner : public Partitioner {$/;"	c	namespace:pq::__anon11	file:
IntermediateUpdate	pqsink.cc	/^IntermediateUpdate::IntermediateUpdate(Str first, Str last,$/;"	f	class:pq::IntermediateUpdate
IntermediateUpdate	pqsink.hh	/^class IntermediateUpdate : public ServerRangeBase {$/;"	c	namespace:pq
Join	pqjoin.hh	/^class Join {$/;"	c	namespace:pq
Join	pqjoin.hh	/^inline Join::Join()$/;"	f	class:pq::Join
JoinRange	pqsink.cc	/^JoinRange::JoinRange(Str first, Str last, Join* join)$/;"	f	class:pq::JoinRange
JoinRange	pqsink.hh	/^class JoinRange : public ServerRangeBase {$/;"	c	namespace:pq
JoinValueType	pqjoin.hh	/^enum JoinValueType {$/;"	g	namespace:pq
KeyCompare	pqdatum.hh	/^struct KeyCompare {$/;"	s	namespace:pq
KeyHook	pqdatum.hh	/^template <typename T> class KeyHook {$/;"	c	namespace:pq
Loadable	pqsink.cc	/^Loadable::Loadable(Table* table) : table_(table) {$/;"	f	class:pq::Loadable
Loadable	pqsink.hh	/^class Loadable {$/;"	c	namespace:pq
Log	pqlog.hh	/^class Log {$/;"	c	namespace:pq
Log	pqlog.hh	/^inline Log::Log(uint64_t epoch) : epoch_(epoch) {$/;"	f	class:pq::Log
Match	pqjoin.hh	/^class Match {$/;"	c	namespace:pq
Match	pqjoin.hh	/^inline Match::Match() {$/;"	f	class:pq::Match
PEQUOD_BASE_HH	pqbase.hh	2;"	d
PEQUOD_DATUM_HH	pqdatum.hh	2;"	d
PEQUOD_PQJOIN_HH	pqjoin.hh	2;"	d
PEQUOD_PQRPC_HH	pqrpc.hh	2;"	d
PEQUOD_SINK_HH	pqsink.hh	2;"	d
PQLOG_HH_	pqlog.hh	2;"	d
PQ_MEMORY_HH_	pqmemory.hh	2;"	d
Pattern	pqjoin.cc	/^Pattern::Pattern() {$/;"	f	class:pq::Pattern
Pattern	pqjoin.hh	/^class Pattern {$/;"	c	namespace:pq
PersistedRange	pqsink.cc	/^PersistedRange::PersistedRange(Table* table, Str first, Str last)$/;"	f	class:pq::PersistedRange
PersistedRange	pqsink.hh	/^class PersistedRange : public ServerRangeBase, public Loadable, public Evictable {$/;"	c	namespace:pq
RangeMatch	pqjoin.hh	/^inline RangeMatch::RangeMatch(Str f, Str l)$/;"	f	class:pq::RangeMatch
RangeMatch	pqjoin.hh	/^inline RangeMatch::RangeMatch(Str f, Str l, const Match& m, int ds)$/;"	f	class:pq::RangeMatch
RangeMatch	pqjoin.hh	/^struct RangeMatch {$/;"	s	namespace:pq
RemoteRange	pqsink.cc	/^RemoteRange::RemoteRange(Table* table, Str first, Str last, int32_t owner)$/;"	f	class:pq::RemoteRange
RemoteRange	pqsink.hh	/^class RemoteRange : public ServerRangeBase, public Loadable, public Evictable {$/;"	c	namespace:pq
RemoteSink	pqsink.cc	/^RemoteSink::RemoteSink(Interconnect* conn, uint32_t peer)$/;"	f	class:pq::RemoteSink
RemoteSink	pqsink.hh	/^class RemoteSink : public Sink {$/;"	c	namespace:pq
Restart	pqsink.cc	/^Restart::Restart(Sink* sink, int joinpos, const Match& m, int notifier)$/;"	f	class:pq::Restart
Restart	pqsink.hh	/^class Restart {$/;"	c	namespace:pq
ServerRangeBase	pqsink.hh	/^class ServerRangeBase {$/;"	c	namespace:pq
ServerRangeBase	pqsink.hh	/^inline ServerRangeBase::ServerRangeBase(Str first, Str last)$/;"	f	class:pq::ServerRangeBase
ServerStore	pqdatum.hh	/^typedef boost::intrusive::set<Datum> ServerStore;$/;"	t	namespace:pq
Sink	pqsink.cc	/^Sink::Sink(JoinRange* jr, SinkRange* sr)$/;"	f	class:pq::Sink
Sink	pqsink.hh	/^class Sink {$/;"	c	namespace:pq
SinkRange	pqsink.cc	/^SinkRange::SinkRange(Str first, Str last, Table* table)$/;"	f	class:pq::SinkRange
SinkRange	pqsink.hh	/^class SinkRange : public ServerRangeBase, public Evictable {$/;"	c	namespace:pq
TwitterPartitioner	pqpartition.cc	/^TwitterPartitioner::TwitterPartitioner(uint32_t nservers, uint32_t nbacking,$/;"	f	class:pq::__anon11::TwitterPartitioner
TwitterPartitioner	pqpartition.cc	/^class TwitterPartitioner : public Partitioner {$/;"	c	namespace:pq::__anon11	file:
UnitTestPartitioner	pqpartition.cc	/^UnitTestPartitioner::UnitTestPartitioner(uint32_t nservers, int default_owner)$/;"	f	class:pq::__anon11::UnitTestPartitioner
UnitTestPartitioner	pqpartition.cc	/^class UnitTestPartitioner : public Partitioner {$/;"	c	namespace:pq::__anon11	file:
add_datum	pqsink.hh	/^inline void Sink::add_datum(Datum* d) const {$/;"	f	class:pq::Sink
add_invalidate	pqsink.cc	/^void Sink::add_invalidate(Str first, Str last) {$/;"	f	class:pq::Sink
add_invalidate	pqsink.cc	/^void Sink::add_invalidate(Str key) {$/;"	f	class:pq::Sink
add_restart	pqsink.cc	/^void Sink::add_restart(int joinpos, const Match& m, int notifier) {$/;"	f	class:pq::Sink
add_sink	pqsink.cc	/^bool SinkRange::add_sink(JoinRange* jr, Server& server,$/;"	f	class:pq::SinkRange
add_update	pqsink.cc	/^void Sink::add_update(int joinpos, Str context, Str key, int notifier) {$/;"	f	class:pq::Sink
add_waiting	pqsink.hh	/^inline void Loadable::add_waiting(tamer::event<> w) {$/;"	f	class:pq::Loadable
address	pqmemory.hh	/^    inline const_pointer address(const_reference t) const {$/;"	f	class:pq::Allocator
address	pqmemory.hh	/^    inline pointer address(reference t) const {$/;"	f	class:pq::Allocator
allocate	pqmemory.cc	/^void* allocate(size_t sz, uint64_t* type) {$/;"	f	namespace:pq
allocate	pqmemory.hh	/^    inline pointer allocate(size_type n, const void* = 0) {$/;"	f	class:pq::Allocator
allocated_key_bytes	pqsink.cc	/^uint64_t ServerRangeBase::allocated_key_bytes = 0;$/;"	m	class:pq::ServerRangeBase	file:
allocated_key_bytes	pqsink.hh	/^    static uint64_t allocated_key_bytes;$/;"	m	class:pq::ServerRangeBase
allow_subtables	pqjoin.cc	/^bool Join::allow_subtables = true;$/;"	m	class:pq::Join	file:
allow_subtables	pqjoin.hh	/^    static bool allow_subtables;$/;"	m	class:pq::Join
analyze	pqjoin.cc	/^int Join::analyze(ErrorHandler* errh) {$/;"	f	class:pq::Join
as_json	pqlog.hh	/^inline const Json& Log::as_json() const {$/;"	f	class:pq::Log
assign_context	pqjoin.hh	/^inline void Join::assign_context(Match& m, Str context) const {$/;"	f	class:pq::Join
assign_optimized_match	pqjoin.hh	/^inline void Pattern::assign_optimized_match(Str str, int mopt, Match& m) const {$/;"	f	class:pq::Pattern
assign_parse	pqjoin.cc	/^bool Join::assign_parse(Str str, ErrorHandler* errh) {$/;"	f	class:pq::Join
attach	pqjoin.cc	/^void Join::attach(Server& server) {$/;"	f	class:pq::Join
back_source	pqjoin.hh	/^inline const Pattern& Join::back_source() const {$/;"	f	class:pq::Join
check_increasing_match	pqjoin.cc	/^bool Join::check_increasing_match(int si, const Match& m) const {$/;"	f	class:pq::Join
check_optimized_match	pqjoin.cc	/^int Pattern::check_optimized_match(const Match& m) const {$/;"	f	class:pq::Pattern
clear	pqjoin.cc	/^void Join::clear() {$/;"	f	class:pq::Join
clear	pqjoin.cc	/^void Pattern::clear() {$/;"	f	class:pq::Pattern
clear	pqjoin.hh	/^inline void Match::clear() {$/;"	f	class:pq::Match
clear	pqlog.hh	/^inline void Log::clear() {$/;"	f	class:pq::Log
clear_updates	pqsink.hh	/^inline void Sink::clear_updates() {$/;"	f	class:pq::Sink
complete	pqsink.cc	/^    bool complete;$/;"	m	struct:pq::SinkRange::validate_args	file:
completion_source	pqjoin.hh	/^inline int Join::completion_source() const {$/;"	f	class:pq::Join
completion_source_	pqjoin.hh	/^    int completion_source_;$/;"	m	class:pq::Join
conn	pqsink.hh	/^inline Interconnect* RemoteSink::conn() const {$/;"	f	class:pq::RemoteSink
conn_	pqsink.hh	/^    Interconnect* conn_;$/;"	m	class:pq::RemoteSink
const_pointer	pqmemory.hh	/^    typedef const T*    const_pointer;$/;"	t	class:pq::Allocator
const_reference	pqmemory.hh	/^    typedef const T&    const_reference;$/;"	t	class:pq::Allocator
construct	pqmemory.hh	/^    inline void construct(pointer p, Args&&... args) {$/;"	f	class:pq::Allocator
context	pqsink.hh	/^inline Str IntermediateUpdate::context() const {$/;"	f	class:pq::IntermediateUpdate
context	pqsink.hh	/^inline Str Restart::context() const {$/;"	f	class:pq::Restart
context	pqsink.hh	/^inline Str Sink::context() const {$/;"	f	class:pq::Sink
context_	pqsink.hh	/^    LocalStr<12> context_;$/;"	m	class:pq::IntermediateUpdate
context_	pqsink.hh	/^    LocalStr<12> context_;$/;"	m	class:pq::Restart
context_	pqsink.hh	/^    LocalStr<12> context_;$/;"	m	class:pq::Sink
context_length	pqjoin.hh	/^inline int Join::context_length(unsigned mask) const {$/;"	f	class:pq::Join
context_length_	pqjoin.hh	/^    uint8_t context_length_[1 << slot_capacity];$/;"	m	class:pq::Join
context_mask	pqjoin.hh	/^inline unsigned Join::context_mask(int si) const {$/;"	f	class:pq::Join
context_mask	pqsink.hh	/^inline unsigned Sink::context_mask() const {$/;"	f	class:pq::Sink
context_mask_	pqjoin.hh	/^    uint8_t context_mask_[pcap];$/;"	m	class:pq::Join
context_mask_	pqsink.hh	/^    unsigned context_mask_;$/;"	m	class:pq::Sink
dangerous_slot	pqjoin.hh	/^    int dangerous_slot;$/;"	m	struct:pq::RangeMatch
dangerous_slot_	pqsink.hh	/^    int dangerous_slot_;$/;"	m	class:pq::Sink
data	pqjoin.hh	/^inline const uint8_t* Match::data(int i) const {$/;"	f	class:pq::Match
data_	pqsink.hh	/^    mutable local_vector<Datum*, 12> data_;$/;"	m	class:pq::Sink
data_free_	pqsink.hh	/^    mutable uintptr_t data_free_;$/;"	m	class:pq::Sink
db_postgres	pqmain.cc	/^enum { db_unknown, db_postgres };$/;"	e	enum:__anon8	file:
db_unknown	pqmain.cc	/^enum { db_unknown, db_postgres };$/;"	e	enum:__anon8	file:
deallocate	pqmemory.cc	/^void deallocate(void* p) {$/;"	f	namespace:pq
deallocate	pqmemory.hh	/^    inline void deallocate(pointer p, size_type) {$/;"	f	class:pq::Allocator
deref	pqdatum.hh	/^inline void Datum::deref() {$/;"	f	class:pq::Datum
deref	pqjoin.hh	/^inline void Join::deref() {$/;"	f	class:pq::Join
deref	pqsink.hh	/^inline void Sink::deref() {$/;"	f	class:pq::Sink
destroy	pqmemory.hh	/^    inline void destroy(pointer p) {$/;"	f	class:pq::Allocator
difference_type	pqmemory.hh	/^    typedef ptrdiff_t   difference_type;$/;"	t	class:pq::Allocator
empty_datum	pqdatum.hh	/^    static const Datum empty_datum;$/;"	m	class:pq::Datum
enable_memory_tracking	pqmemory.hh	/^enum { enable_memory_tracking = 1 };$/;"	e	enum:pq::__anon10
endpoint_type	pqsink.hh	/^    typedef Str endpoint_type;$/;"	t	class:pq::IntermediateUpdate
endpoint_type	pqsink.hh	/^    typedef Str endpoint_type;$/;"	t	class:pq::ServerRangeBase
epoch_	pqlog.hh	/^    uint64_t epoch_;$/;"	m	class:pq::Log
erase_marker	pqbase.hh	/^inline String erase_marker() {$/;"	f	namespace:pq
evict	pqsink.cc	/^void PersistedRange::evict() {$/;"	f	class:pq::PersistedRange
evict	pqsink.cc	/^void RemoteRange::evict() {$/;"	f	class:pq::RemoteRange
evict	pqsink.cc	/^void SinkRange::evict() {$/;"	f	class:pq::SinkRange
evicted	pqsink.hh	/^inline bool Evictable::evicted() const {$/;"	f	class:pq::Evictable
evicted_	pqsink.hh	/^    bool evicted_;$/;"	m	class:pq::Evictable
expand	pqjoin.cc	/^int Pattern::expand(uint8_t* s, const Match& m) const {$/;"	f	class:pq::Pattern
expand_first	pqjoin.cc	/^String Join::expand_first(const Pattern& pat, const RangeMatch& rm) const {$/;"	f	class:pq::Join
expand_first	pqjoin.cc	/^int Join::expand_first(uint8_t* buf, const Pattern& pat,$/;"	f	class:pq::Join
expand_last	pqjoin.cc	/^String Join::expand_last(const Pattern& pat, const RangeMatch& rm) const {$/;"	f	class:pq::Join
expand_last	pqjoin.cc	/^int Join::expand_last(uint8_t* buf, const Pattern& pat,$/;"	f	class:pq::Join
expand_sink_key_context	pqjoin.hh	/^inline void Join::expand_sink_key_context(Str context) const {$/;"	f	class:pq::Join
expand_sink_key_source	pqjoin.hh	/^inline void Join::expand_sink_key_source(Str source_key, unsigned mask) const {$/;"	f	class:pq::Join
expires_at_	pqsink.hh	/^    uint64_t expires_at_;$/;"	m	class:pq::Sink
filtermatch	pqsink.cc	/^    Match::state filtermatch;$/;"	m	struct:pq::SinkRange::validate_args	file:
filters	pqsink.cc	/^    int filters;$/;"	m	struct:pq::SinkRange::validate_args	file:
filters_	pqjoin.hh	/^    uint8_t filters_;$/;"	m	class:pq::Join
first	pqjoin.hh	/^    Str first;$/;"	m	struct:pq::RangeMatch
hard_assign_parse	pqjoin.cc	/^int Join::hard_assign_parse(Str str, ErrorHandler* errh) {$/;"	f	class:pq::Join
has_expired	pqsink.hh	/^inline bool Sink::has_expired(uint64_t now) const {$/;"	f	class:pq::Sink
has_slot	pqjoin.hh	/^inline bool Match::has_slot(int i) const {$/;"	f	class:pq::Match
has_slot	pqjoin.hh	/^inline bool Pattern::has_slot(int slot) const {$/;"	f	class:pq::Pattern
heap_type	pqmemory.hh	/^struct heap_type {$/;"	s	namespace:pq
hint	pqsink.hh	/^inline Datum* Sink::hint() const {$/;"	f	class:pq::Sink
hint_	pqsink.hh	/^    mutable Datum* hint_;$/;"	m	class:pq::Sink
ibegin	pqsink.hh	/^inline Str ServerRangeBase::ibegin() const {$/;"	f	class:pq::ServerRangeBase
ibegin	pqsink.hh	/^inline Str Sink::ibegin() const {$/;"	f	class:pq::Sink
ibegin_	pqsink.hh	/^    LocalStr<24> ibegin_;$/;"	m	class:pq::ServerRangeBase
iend	pqsink.hh	/^inline Str ServerRangeBase::iend() const {$/;"	f	class:pq::ServerRangeBase
iend	pqsink.hh	/^inline Str Sink::iend() const {$/;"	f	class:pq::Sink
iend_	pqsink.hh	/^    LocalStr<24> iend_;$/;"	m	class:pq::ServerRangeBase
interval	pqsink.hh	/^inline ::interval<Str> Sink::interval() const {$/;"	f	class:pq::Sink
interval	pqsink.hh	/^inline interval<Str> ServerRangeBase::interval() const {$/;"	f	class:pq::ServerRangeBase
invalidate	pqdatum.hh	/^inline void Datum::invalidate() {$/;"	f	class:pq::Datum
invalidate	pqsink.cc	/^void Sink::invalidate() {$/;"	f	class:pq::Sink
invalidate_hit_keys	pqsink.cc	/^uint64_t Sink::invalidate_hit_keys = 0;$/;"	m	class:pq::Sink	file:
invalidate_hit_keys	pqsink.hh	/^    static uint64_t invalidate_hit_keys;$/;"	m	class:pq::Sink
invalidate_marker	pqbase.hh	/^inline String invalidate_marker() {$/;"	f	namespace:pq
invalidate_miss_keys	pqsink.cc	/^uint64_t Sink::invalidate_miss_keys = 0;$/;"	m	class:pq::Sink	file:
invalidate_miss_keys	pqsink.hh	/^    static uint64_t invalidate_miss_keys;$/;"	m	class:pq::Sink
is_erase_marker	pqbase.hh	/^inline bool is_erase_marker(const String& str) {$/;"	f	namespace:pq
is_invalidate_marker	pqbase.hh	/^inline bool is_invalidate_marker(const String& str) {$/;"	f	namespace:pq
is_linked	pqsink.cc	/^bool Evictable::is_linked() const {$/;"	f	class:pq::Evictable
is_marker	pqbase.hh	/^inline bool is_marker(const String& str) {$/;"	f	namespace:pq
is_table	pqdatum.hh	/^inline bool Datum::is_table() const {$/;"	f	class:pq::Datum
is_unchanged_marker	pqbase.hh	/^inline bool is_unchanged_marker(const String& str) {$/;"	f	namespace:pq
join	pqsink.hh	/^inline Join* JoinRange::join() const {$/;"	f	class:pq::JoinRange
join	pqsink.hh	/^inline Join* Sink::join() const {$/;"	f	class:pq::Sink
join_	pqsink.hh	/^    Join* join_;$/;"	m	class:pq::JoinRange
joinpos_	pqsink.hh	/^    int joinpos_;$/;"	m	class:pq::IntermediateUpdate
joinpos_	pqsink.hh	/^    int joinpos_;$/;"	m	class:pq::Restart
jr_	pqsink.hh	/^    JoinRange* jr_;$/;"	m	class:pq::Sink
jvt	pqjoin.hh	/^inline JoinValueType Join::jvt() const {$/;"	f	class:pq::Join
jvt_	pqjoin.hh	/^    int jvt_;$/;"	m	class:pq::Join
jvt_bounded_copy_last	pqjoin.hh	/^    jvt_bounded_copy_last, jvt_bounded_count_match,$/;"	e	enum:pq::JoinValueType
jvt_bounded_count_match	pqjoin.hh	/^    jvt_bounded_copy_last, jvt_bounded_count_match,$/;"	e	enum:pq::JoinValueType
jvt_config	pqjoin.hh	/^inline const Json& Join::jvt_config() const {$/;"	f	class:pq::Join
jvt_copy_last	pqjoin.hh	/^    jvt_copy_last = 0, jvt_min_last, jvt_max_last,$/;"	e	enum:pq::JoinValueType
jvt_count_match	pqjoin.hh	/^    jvt_count_match, jvt_sum_match,$/;"	e	enum:pq::JoinValueType
jvt_filter	pqjoin.hh	/^    jvt_using, jvt_filter, jvt_slotdef, jvt_slotdef1$/;"	e	enum:pq::JoinValueType
jvt_max_last	pqjoin.hh	/^    jvt_copy_last = 0, jvt_min_last, jvt_max_last,$/;"	e	enum:pq::JoinValueType
jvt_min_last	pqjoin.hh	/^    jvt_copy_last = 0, jvt_min_last, jvt_max_last,$/;"	e	enum:pq::JoinValueType
jvt_slotdef	pqjoin.hh	/^    jvt_using, jvt_filter, jvt_slotdef, jvt_slotdef1$/;"	e	enum:pq::JoinValueType
jvt_slotdef1	pqjoin.hh	/^    jvt_using, jvt_filter, jvt_slotdef, jvt_slotdef1$/;"	e	enum:pq::JoinValueType
jvt_sum_match	pqjoin.hh	/^    jvt_count_match, jvt_sum_match,$/;"	e	enum:pq::JoinValueType
jvt_using	pqjoin.hh	/^    jvt_using, jvt_filter, jvt_slotdef, jvt_slotdef1$/;"	e	enum:pq::JoinValueType
jvtparam_	pqjoin.hh	/^    Json jvtparam_;$/;"	m	class:pq::Join
key	pqdatum.hh	/^inline Str Datum::key() const {$/;"	f	class:pq::Datum
key_	pqdatum.hh	/^    LocalStr<24> key_;$/;"	m	class:pq::Datum
key_capacity	pqbase.hh	/^enum { key_capacity = 128 };$/;"	e	enum:pq::__anon1
key_holder	pqdatum.hh	/^    inline const T& key_holder() const {$/;"	f	class:pq::KeyHook
key_length	pqjoin.hh	/^inline int Pattern::key_length() const {$/;"	f	class:pq::Pattern
key_type	pqdatum.hh	/^    typedef Str key_type;$/;"	t	class:pq::Datum
klen_	pqjoin.hh	/^    uint8_t klen_;$/;"	m	class:pq::Pattern
known_length	pqjoin.hh	/^inline int Match::known_length(const state& state, int i) {$/;"	f	class:pq::Match
known_length	pqjoin.hh	/^inline int Match::known_length(int i) const {$/;"	f	class:pq::Match
known_mask	pqjoin.hh	/^inline unsigned Join::known_mask(const Match& m) const {$/;"	f	class:pq::Join
known_mask	pqjoin.hh	/^inline unsigned Join::known_mask(const Match::state& mstate) const {$/;"	f	class:pq::Join
last	pqjoin.hh	/^    Str last;$/;"	m	struct:pq::RangeMatch
last_access	pqsink.hh	/^inline uint64_t Evictable::last_access() const {$/;"	f	class:pq::Evictable
last_access_	pqsink.hh	/^    uint64_t last_access_;$/;"	m	class:pq::Evictable
lazy_	pqjoin.hh	/^    uint8_t lazy_;$/;"	m	class:pq::Join
log	pqsink.cc	/^    uint32_t& log;$/;"	m	struct:pq::SinkRange::validate_args	file:
log_	pqlog.hh	/^    Json log_;$/;"	m	class:pq::Log
lru_hook	pqsink.hh	/^typedef bi::list_base_hook<bi::link_mode<bi::auto_unlink>> lru_hook;$/;"	t	namespace:pq
main	pqmain.cc	/^int main(int argc, char** argv) {$/;"	f
maintained	pqjoin.hh	/^inline bool Join::maintained() const {$/;"	f	class:pq::Join
maintained_	pqjoin.hh	/^    bool maintained_;   \/\/ if the output is kept up to date with changes to the input$/;"	m	class:pq::Join
make	pqpartition.cc	/^Partitioner *Partitioner::make(const String &name, uint32_t nbacking,$/;"	f	class:pq::Partitioner
make	pqpartition.cc	/^Partitioner *Partitioner::make(const String &name, uint32_t nservers,$/;"	f	class:pq::Partitioner
make_context	pqjoin.hh	/^inline void Join::make_context(LocalStr<C>& str, const Match& m, unsigned mask) const {$/;"	f	class:pq::Join
make_source	pqjoin.cc	/^SourceRange* Join::make_source(Server& server, const Match& m,$/;"	f	class:pq::Join
mark_evicted	pqsink.hh	/^inline void Evictable::mark_evicted() {$/;"	f	class:pq::Evictable
marker_data	pqbase.cc	/^const char marker_data[] = "UEI";$/;"	m	namespace:pq	file:
match	pqjoin.hh	/^    Match match;$/;"	m	struct:pq::RangeMatch
match	pqjoin.hh	/^inline bool Pattern::match(Str s, Match& m) const {$/;"	f	class:pq::Pattern
match	pqjoin.hh	/^inline bool Pattern::match(Str str) const {$/;"	f	class:pq::Pattern
match_range	pqjoin.cc	/^void Pattern::match_range(RangeMatch& rm) const {$/;"	f	class:pq::Pattern
max_datum	pqdatum.hh	/^    static const Datum max_datum;$/;"	m	class:pq::Datum
max_size	pqmemory.hh	/^    inline size_type max_size() const throw() {$/;"	f	class:pq::Allocator
maxrss_mb	pqmemory.hh	/^inline uint32_t maxrss_mb(int32_t rss) {$/;"	f	namespace:pq
mem_other_size	pqmemory.cc	/^uint64_t mem_other_size = 0;$/;"	m	namespace:pq	file:
mem_overhead_size	pqmemory.cc	/^uint64_t mem_overhead_size = 0;$/;"	m	namespace:pq	file:
mem_store_size	pqmemory.cc	/^uint64_t mem_store_size = 0;$/;"	m	namespace:pq	file:
member_hook_	pqdatum.hh	/^    pequod_set_member_hook member_hook_;$/;"	m	class:pq::Datum
meminfo	pqmemory.cc	/^struct meminfo {$/;"	s	namespace:pq::__anon9	file:
mode_hn	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
mode_listen	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
mode_tests	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
mode_twitter	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
mode_twitternew	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
mode_unknown	pqmain.cc	/^enum { mode_unknown, mode_twitter, mode_twitternew, mode_hn, mode_listen, mode_tests };$/;"	e	enum:__anon7	file:
ms_	pqjoin.hh	/^    state ms_;$/;"	m	class:pq::Match
need_restart	pqsink.hh	/^inline bool Sink::need_restart() const {$/;"	f	class:pq::Sink
need_update	pqsink.hh	/^inline bool Sink::need_update() const {$/;"	f	class:pq::Sink
notifier	pqsink.cc	/^    int notifier;$/;"	m	struct:pq::SinkRange::validate_args	file:
notifier	pqsink.hh	/^inline int IntermediateUpdate::notifier() const {$/;"	f	class:pq::IntermediateUpdate
notifier	pqsink.hh	/^inline int Restart::notifier() const {$/;"	f	class:pq::Restart
notifier_	pqsink.hh	/^    int notifier_;$/;"	m	class:pq::IntermediateUpdate
notifier_	pqsink.hh	/^    int notifier_;$/;"	m	class:pq::Restart
notify_waiting	pqsink.hh	/^inline void Loadable::notify_waiting() {$/;"	f	class:pq::Loadable
now	pqsink.cc	/^    uint64_t now;$/;"	m	struct:pq::SinkRange::validate_args	file:
npat_	pqjoin.hh	/^    int npat_;$/;"	m	class:pq::Join
npattern	pqjoin.hh	/^inline int Join::npattern() const {$/;"	f	class:pq::Join
nsource	pqjoin.hh	/^inline int Join::nsource() const {$/;"	f	class:pq::Join
operator !=	pqjoin.hh	/^inline bool operator!=(const Pattern& a, const Pattern& b) {$/;"	f	namespace:pq
operator ()	pqdatum.hh	/^    inline bool operator()(Str a, const KeyHook<K>& b) const {$/;"	f	struct:pq::KeyCompare
operator ()	pqdatum.hh	/^    inline bool operator()(const KeyHook<K>& a, Str b) const {$/;"	f	struct:pq::KeyCompare
operator ()	pqdatum.hh	/^    inline bool operator()(const KeyHook<K>& a, const String_base<T>& b) const {$/;"	f	struct:pq::KeyCompare
operator ()	pqdatum.hh	/^    inline bool operator()(const String_base<T>& a, const KeyHook<K>& b) const {$/;"	f	struct:pq::KeyCompare
operator ()	pqdatum.hh	/^    inline void operator()(Datum* ptr) {$/;"	f	struct:pq::DatumDispose
operator <	pqdatum.hh	/^inline bool operator<(const Datum& a, const Datum& b) {$/;"	f	namespace:pq
operator <	pqsink.hh	/^inline bool operator<(const Sink& a, const Sink& b) {$/;"	f	namespace:pq
operator <<	pqdatum.hh	/^inline std::ostream& operator<<(std::ostream& stream, const Datum& d) {$/;"	f	namespace:pq
operator <<	pqjoin.cc	/^std::ostream& operator<<(std::ostream& stream, const Join& join) {$/;"	f	namespace:pq
operator <<	pqjoin.cc	/^std::ostream& operator<<(std::ostream& stream, const Match& m) {$/;"	f	namespace:pq
operator <<	pqjoin.cc	/^std::ostream& operator<<(std::ostream& stream, const Pattern& m) {$/;"	f	namespace:pq
operator <<	pqsink.cc	/^std::ostream& operator<<(std::ostream& stream, const IntermediateUpdate& iu) {$/;"	f	namespace:pq
operator <<	pqsink.cc	/^std::ostream& operator<<(std::ostream& stream, const Sink& sink) {$/;"	f	namespace:pq
operator ==	pqdatum.hh	/^inline bool operator==(const Datum& a, const Datum& b) {$/;"	f	namespace:pq
operator ==	pqjoin.cc	/^bool operator==(const Pattern& a, const Pattern& b) {$/;"	f	namespace:pq
operator >	pqdatum.hh	/^inline bool operator>(const Datum& a, const Datum& b) {$/;"	f	namespace:pq
operator delete	pqmemory.cc	/^void operator delete(void *p) {$/;"	f
operator delete[]	pqmemory.cc	/^void operator delete[](void *p) {$/;"	f
operator new	pqmemory.cc	/^void* operator new(size_t size) {$/;"	f
operator new	pqmemory.cc	/^void* operator new(size_t size, uint64_t* type) {$/;"	f
operator new[]	pqmemory.cc	/^void* operator new[](size_t size) {$/;"	f
operator new[]	pqmemory.cc	/^void* operator new[](size_t size, uint64_t* type) {$/;"	f
options	pqmain.cc	/^static Clp_Option options[] = {$/;"	v	file:
other	pqmemory.hh	/^        typedef Allocator<U> other;$/;"	t	struct:pq::Allocator::rebind
owner	pqdatum.hh	/^inline const Sink* Datum::owner() const {$/;"	f	class:pq::Datum
owner	pqsink.hh	/^inline int32_t RemoteRange::owner() const {$/;"	f	class:pq::RemoteRange
owner_	pqdatum.hh	/^    const Sink* owner_;$/;"	m	class:pq::Datum
owner_	pqsink.hh	/^    int32_t owner_;$/;"	m	class:pq::RemoteRange
owner_position_	pqdatum.hh	/^    int owner_position_;$/;"	m	class:pq::Datum
parse_slot_name	pqjoin.cc	/^int Join::parse_slot_name(Str word, ErrorHandler* errh) {$/;"	f	class:pq::Join
parse_slot_names	pqjoin.cc	/^int Join::parse_slot_names(Str word, String& out, ErrorHandler* errh) {$/;"	f	class:pq::Join
pat_	pqjoin.hh	/^    Pattern pat_[pcap];$/;"	m	class:pq::Join
pat_	pqjoin.hh	/^    uint8_t pat_[pcap];$/;"	m	class:pq::Pattern
pat_mask_	pqjoin.hh	/^    uint8_t pat_mask_[pcap];$/;"	m	class:pq::Join
pattern	pqjoin.hh	/^inline const Pattern& Join::pattern(int i) const {$/;"	f	class:pq::Join
pattern_subtable_length	pqjoin.cc	/^int Join::pattern_subtable_length(int i) const {$/;"	f	class:pq::Join
pcap	pqjoin.hh	/^    enum { pcap = 12 };$/;"	e	enum:pq::Pattern::__anon4
pcap	pqjoin.hh	/^    enum { pcap = source_capacity + 1 };$/;"	e	enum:pq::Join::__anon5
peer	pqsink.hh	/^inline uint32_t RemoteSink::peer() const {$/;"	f	class:pq::RemoteSink
peer_	pqsink.hh	/^    uint32_t peer_;$/;"	m	class:pq::RemoteSink
pending	pqsink.cc	/^    tamer::gather_rendezvous& pending;$/;"	m	struct:pq::SinkRange::validate_args	file:
pending	pqsink.hh	/^inline bool Loadable::pending() const {$/;"	f	class:pq::Loadable
pequod_set_base_hook	pqdatum.hh	/^    boost::intrusive::optimize_size<true> > pequod_set_base_hook;$/;"	t	namespace:pq
pequod_set_member_hook	pqdatum.hh	/^    boost::intrusive::optimize_size<true> > pequod_set_member_hook;$/;"	t	namespace:pq
plen_	pqjoin.hh	/^    uint8_t plen_;$/;"	m	class:pq::Pattern
pointer	pqmemory.hh	/^    typedef T*          pointer;$/;"	t	class:pq::Allocator
pq	pqbase.cc	/^namespace pq {$/;"	n	file:
pq	pqbase.hh	/^namespace pq {$/;"	n
pq	pqdatum.hh	/^namespace pq {$/;"	n
pq	pqjoin.cc	/^namespace pq {$/;"	n	file:
pq	pqjoin.hh	/^namespace pq {$/;"	n
pq	pqlog.hh	/^namespace pq {$/;"	n
pq	pqmemory.cc	/^namespace pq {$/;"	n	file:
pq	pqmemory.hh	/^namespace pq {$/;"	n
pq	pqpartition.cc	/^namespace pq {$/;"	n	file:
pq	pqsink.cc	/^namespace pq {$/;"	n	file:
pq	pqsink.hh	/^namespace pq {$/;"	n
pq_add_join	pqrpc.hh	/^    pq_add_join = 11,$/;"	e	enum:__anon12
pq_control	pqrpc.hh	/^    pq_control = 13,$/;"	e	enum:__anon12
pq_count	pqrpc.hh	/^    pq_count = 6,$/;"	e	enum:__anon12
pq_erase	pqrpc.hh	/^    pq_erase = 3,$/;"	e	enum:__anon12
pq_fail	pqrpc.hh	/^    pq_fail = -1$/;"	e	enum:__anon13
pq_get	pqrpc.hh	/^    pq_get = 1,$/;"	e	enum:__anon12
pq_insert	pqrpc.hh	/^    pq_insert = 2,$/;"	e	enum:__anon12
pq_invalidate	pqrpc.hh	/^    pq_invalidate = 10,$/;"	e	enum:__anon12
pq_noop_get	pqrpc.hh	/^    pq_noop_get = 14$/;"	e	enum:__anon12
pq_notify_erase	pqrpc.hh	/^    pq_notify_erase = 5,$/;"	e	enum:__anon12
pq_notify_insert	pqrpc.hh	/^    pq_notify_insert = 4,$/;"	e	enum:__anon12
pq_ok	pqrpc.hh	/^    pq_ok = 0,$/;"	e	enum:__anon13
pq_scan	pqrpc.hh	/^    pq_scan = 7,$/;"	e	enum:__anon12
pq_stats	pqrpc.hh	/^    pq_stats = 12,$/;"	e	enum:__anon12
pq_subscribe	pqrpc.hh	/^    pq_subscribe = 8,$/;"	e	enum:__anon12
pq_unsubscribe	pqrpc.hh	/^    pq_unsubscribe = 9,$/;"	e	enum:__anon12
prefixes_	pqpartition.cc	/^    static const char prefixes_[];$/;"	m	class:pq::__anon11::UnitTestPartitioner	file:
prefixes_	pqpartition.cc	/^const char UnitTestPartitioner::prefixes_[] =$/;"	m	class:pq::__anon11::UnitTestPartitioner	file:
pri_max	pqsink.hh	/^    enum { pri_none = 0, pri_persistent, pri_sink, pri_remote, pri_max };$/;"	e	enum:pq::Evictable::__anon14
pri_none	pqsink.hh	/^    enum { pri_none = 0, pri_persistent, pri_sink, pri_remote, pri_max };$/;"	e	enum:pq::Evictable::__anon14
pri_persistent	pqsink.hh	/^    enum { pri_none = 0, pri_persistent, pri_sink, pri_remote, pri_max };$/;"	e	enum:pq::Evictable::__anon14
pri_remote	pqsink.hh	/^    enum { pri_none = 0, pri_persistent, pri_sink, pri_remote, pri_max };$/;"	e	enum:pq::Evictable::__anon14
pri_sink	pqsink.hh	/^    enum { pri_none = 0, pri_persistent, pri_sink, pri_remote, pri_max };$/;"	e	enum:pq::Evictable::__anon14
priority	pqsink.cc	/^uint32_t Evictable::priority() const {$/;"	f	class:pq::Evictable
priority	pqsink.cc	/^uint32_t PersistedRange::priority() const {$/;"	f	class:pq::PersistedRange
priority	pqsink.cc	/^uint32_t RemoteRange::priority() const {$/;"	f	class:pq::RemoteRange
priority	pqsink.cc	/^uint32_t SinkRange::priority() const {$/;"	f	class:pq::SinkRange
range	pqsink.hh	/^inline SinkRange* Sink::range() const {$/;"	f	class:pq::Sink
rblinks_	pqsink.hh	/^    rblinks<IntermediateUpdate> rblinks_;$/;"	m	class:pq::IntermediateUpdate
rblinks_	pqsink.hh	/^    rblinks<JoinRange> rblinks_;$/;"	m	class:pq::JoinRange
rblinks_	pqsink.hh	/^    rblinks<PersistedRange> rblinks_;$/;"	m	class:pq::PersistedRange
rblinks_	pqsink.hh	/^    rblinks<RemoteRange> rblinks_;$/;"	m	class:pq::RemoteRange
rblinks_	pqsink.hh	/^    rblinks<SinkRange> rblinks_;$/;"	m	class:pq::SinkRange
rebind	pqmemory.hh	/^    struct rebind {$/;"	s	class:pq::Allocator
record	pqlog.hh	/^inline void Log::record(Str key, const T& value) {$/;"	f	class:pq::Log
record_at	pqlog.hh	/^inline void Log::record_at(Str key, uint64_t time, const T& value) {$/;"	f	class:pq::Log
ref	pqdatum.hh	/^inline void Datum::ref() {$/;"	f	class:pq::Datum
ref	pqjoin.hh	/^inline void Join::ref() {$/;"	f	class:pq::Join
ref	pqsink.hh	/^inline void Sink::ref() {$/;"	f	class:pq::Sink
refcount_	pqdatum.hh	/^    int refcount_;$/;"	m	class:pq::Datum
refcount_	pqjoin.hh	/^    int refcount_;$/;"	m	class:pq::Join
refcount_	pqsink.hh	/^    int refcount_;$/;"	m	class:pq::Sink
reference	pqmemory.hh	/^    typedef T&          reference;$/;"	t	class:pq::Allocator
remove_datum	pqsink.hh	/^inline void Sink::remove_datum(Datum* d) const {$/;"	f	class:pq::Sink
restart	pqsink.cc	/^bool Sink::restart(Str first, Str last, Server& server,$/;"	f	class:pq::Sink
restarts_	pqsink.hh	/^    std::list<Restart*> restarts_;$/;"	m	class:pq::Sink
restore	pqjoin.hh	/^inline void Match::restore(const state& state) {$/;"	f	class:pq::Match
rm	pqsink.cc	/^    RangeMatch rm;$/;"	m	struct:pq::SinkRange::validate_args	file:
same_structure	pqjoin.cc	/^bool Join::same_structure(const Join& x) const {$/;"	f	class:pq::Join
save	pqjoin.hh	/^inline const Match::state& Match::save() const {$/;"	f	class:pq::Match
server	pqjoin.hh	/^inline Server& Join::server() const {$/;"	f	class:pq::Join
server	pqsink.cc	/^    Server* server;$/;"	m	struct:pq::SinkRange::validate_args	file:
server_	pqjoin.hh	/^    Server* server_;$/;"	m	class:pq::Join
set_expiration	pqsink.hh	/^inline void Sink::set_expiration(uint64_t from) {$/;"	f	class:pq::Sink
set_last_access	pqsink.hh	/^inline void Evictable::set_last_access(uint64_t now) {$/;"	f	class:pq::Evictable
set_slot	pqjoin.hh	/^inline void Match::set_slot(int i, const char* data, int len) {$/;"	f	class:pq::Match
set_slot	pqjoin.hh	/^inline void Match::set_slot(int i, const uint8_t* data, int len) {$/;"	f	class:pq::Match
set_staleness	pqjoin.cc	/^void Join::set_staleness(double s) {$/;"	f	class:pq::Join
set_subtree_iend	pqsink.hh	/^inline void ServerRangeBase::set_subtree_iend(Str subtree_iend) {$/;"	f	class:pq::ServerRangeBase
sink	pqjoin.hh	/^inline const Pattern& Join::sink() const {$/;"	f	class:pq::Join
sink	pqsink.cc	/^    Sink* sink;$/;"	m	struct:pq::SinkRange::validate_args	file:
sink_key	pqjoin.hh	/^inline Str Join::sink_key() const {$/;"	f	class:pq::Join
sink_key_	pqjoin.hh	/^    mutable LocalStr<24> sink_key_;$/;"	m	class:pq::Join
sinks_	pqsink.hh	/^    local_vector<Sink*, 4> sinks_;$/;"	m	class:pq::SinkRange
size_type	pqmemory.hh	/^    typedef size_t      size_type;$/;"	t	class:pq::Allocator
slot	pqjoin.hh	/^inline Str Match::slot(int i) const {$/;"	f	class:pq::Match
slot	pqjoin.hh	/^inline int Join::slot(Str name) const {$/;"	f	class:pq::Join
slot_	pqjoin.hh	/^    const uint8_t* slot_[slot_capacity];$/;"	m	class:pq::Match
slot_capacity	pqjoin.hh	/^enum { slot_capacity = 5 };$/;"	e	enum:pq::__anon2
slot_length	pqjoin.hh	/^inline int Pattern::slot_length(int slot) const {$/;"	f	class:pq::Pattern
slot_position	pqjoin.hh	/^inline int Pattern::slot_position(int slot) const {$/;"	f	class:pq::Pattern
slotlen_	pqjoin.hh	/^        uint8_t slotlen_[(slot_capacity + 3) & ~3];$/;"	m	class:pq::Match::state
slotlen_	pqjoin.hh	/^    uint8_t slotlen_[slot_capacity];$/;"	m	class:pq::Join
slotlen_	pqjoin.hh	/^    uint8_t slotlen_[slot_capacity];$/;"	m	class:pq::Pattern
slotname_	pqjoin.hh	/^    String slotname_[slot_capacity];$/;"	m	class:pq::Join
slotpos_	pqjoin.hh	/^    uint8_t slotpos_[slot_capacity];$/;"	m	class:pq::Pattern
slottype_	pqjoin.hh	/^    uint8_t slottype_[slot_capacity];$/;"	m	class:pq::Join
source	pqjoin.hh	/^inline const Pattern& Join::source(int si) const {$/;"	f	class:pq::Join
source_capacity	pqjoin.hh	/^enum { source_capacity = 4 };$/;"	e	enum:pq::__anon3
source_is_filter	pqjoin.hh	/^inline bool Join::source_is_filter(int si) const {$/;"	f	class:pq::Join
source_is_lazy	pqjoin.hh	/^inline bool Join::source_is_lazy(int si) const {$/;"	f	class:pq::Join
source_mask	pqjoin.hh	/^inline unsigned Join::source_mask(int si) const {$/;"	f	class:pq::Join
sourcet	pqsink.cc	/^    Table* sourcet[source_capacity];$/;"	m	struct:pq::SinkRange::validate_args	file:
sr_	pqsink.cc	/^      jr_(jr), sr_(sr) {$/;"	f	namespace:pq
sr_	pqsink.hh	/^    SinkRange* sr_;$/;"	m	class:pq::Sink
staleness	pqjoin.hh	/^inline uint64_t Join::staleness() const {$/;"	f	class:pq::Join
staleness_	pqjoin.hh	/^    uint64_t staleness_;  \/\/ validated ranges can be used in this time window.$/;"	m	class:pq::Join
state	pqjoin.hh	/^    class state {$/;"	c	class:pq::Match
store	pqmemory.hh	/^    typedef pq::Allocator<T, &mem_store_size> store;$/;"	t	struct:pq::heap_type
stype_binary_number	pqjoin.hh	/^        stype_binary_number = 3, stype_type_mask = 3,$/;"	e	enum:pq::Join::__anon6
stype_decimal	pqjoin.hh	/^        stype_unknown = 0, stype_text = 1, stype_decimal = 2,$/;"	e	enum:pq::Join::__anon6
stype_subtables	pqjoin.hh	/^        stype_subtables = 4$/;"	e	enum:pq::Join::__anon6
stype_text	pqjoin.hh	/^        stype_unknown = 0, stype_text = 1, stype_decimal = 2,$/;"	e	enum:pq::Join::__anon6
stype_type_mask	pqjoin.hh	/^        stype_binary_number = 3, stype_type_mask = 3,$/;"	e	enum:pq::Join::__anon6
stype_unknown	pqjoin.hh	/^        stype_unknown = 0, stype_text = 1, stype_decimal = 2,$/;"	e	enum:pq::Join::__anon6
subtree_iend	pqsink.hh	/^inline Str ServerRangeBase::subtree_iend() const {$/;"	f	class:pq::ServerRangeBase
subtree_iend_	pqsink.hh	/^    Str subtree_iend_;$/;"	m	class:pq::ServerRangeBase
sz	pqmemory.cc	/^    size_t sz;$/;"	m	struct:pq::__anon9::meminfo	file:
table	pqsink.hh	/^inline Table* Loadable::table() const {$/;"	f	class:pq::Loadable
table	pqsink.hh	/^inline Table* Sink::table() const {$/;"	f	class:pq::Sink
table_	pqsink.hh	/^    Table* table_;$/;"	m	class:pq::Loadable
table_	pqsink.hh	/^    Table* table_;$/;"	m	class:pq::Sink
table_	pqsink.hh	/^    Table* table_;$/;"	m	class:pq::SinkRange
table_marker	pqdatum.hh	/^    static const char table_marker[];$/;"	m	class:pq::Datum
table_name	pqbase.hh	/^inline T table_name(const String_base<T>& key) {$/;"	f	namespace:pq
table_name	pqbase.hh	/^inline T table_name(const String_base<T>& key, const String_base<T>& key2) {$/;"	f	namespace:pq
table_name	pqjoin.hh	/^inline Str Pattern::table_name() const {$/;"	f	class:pq::Pattern
test_annotation	pqunit.cc	/^void test_annotation() {$/;"	f	namespace:__anon15
test_celebrity	pqunit.cc	/^void test_celebrity() {$/;"	f	namespace:__anon15
test_count	pqunit.cc	/^void test_count() {$/;"	f	namespace:__anon15
test_cross	pqunit.cc	/^void test_cross() {$/;"	f	namespace:__anon15
test_expansion	pqunit.cc	/^void test_expansion() {$/;"	f	namespace:__anon15
test_func	pqunit.cc	/^typedef void (*test_func)();$/;"	t	namespace:__anon15	file:
test_iupdate	pqunit.cc	/^void test_iupdate() {$/;"	f	namespace:__anon15
test_iupdate2	pqunit.cc	/^void test_iupdate2() {$/;"	f	namespace:__anon15
test_iupdate3	pqunit.cc	/^void test_iupdate3() {$/;"	f	namespace:__anon15
test_iupdate4	pqunit.cc	/^void test_iupdate4() {$/;"	f	namespace:__anon15
test_iupdate_t	pqunit.cc	/^void test_iupdate_t() {$/;"	f	namespace:__anon15
test_join1	pqunit.cc	/^void test_join1() {$/;"	f	namespace:__anon15
test_karma	pqunit.cc	/^void test_karma() {$/;"	f	namespace:__anon15
test_karma_online	pqunit.cc	/^void test_karma_online() {$/;"	f	namespace:__anon15
test_lazy_eager	pqunit.cc	/^void test_lazy_eager() {$/;"	f	namespace:__anon15
test_ma	pqunit.cc	/^void test_ma() {$/;"	f	namespace:__anon15
test_op_count	pqunit.cc	/^void test_op_count() {$/;"	f	namespace:__anon15
test_op_count_validate1	pqunit.cc	/^void test_op_count_validate1() {$/;"	f	namespace:__anon15
test_op_max	pqunit.cc	/^void test_op_max() {$/;"	f	namespace:__anon15
test_op_min	pqunit.cc	/^void test_op_min() {$/;"	f	namespace:__anon15
test_op_sum	pqunit.cc	/^void test_op_sum() {$/;"	f	namespace:__anon15
test_overlap	pqunit.cc	/^void test_overlap() {$/;"	f	namespace:__anon15
test_partitioner_analyze	pqunit.cc	/^void test_partitioner_analyze() {$/;"	f	namespace:__anon15
test_recursive	pqunit.cc	/^void test_recursive() {$/;"	f	namespace:__anon15
test_simple	pqunit.cc	/^void test_simple() {$/;"	f	namespace:__anon15
test_string	pqunit.cc	/^void test_string() {$/;"	f
test_swap	pqunit.cc	/^void test_swap() {$/;"	f	namespace:__anon15
type	pqmemory.cc	/^    uint64_t* type;$/;"	m	struct:pq::__anon9::meminfo	file:
unchanged_marker	pqbase.hh	/^inline String unchanged_marker() {$/;"	f	namespace:pq
unit_tests	pqunit.cc	/^void unit_tests(const std::set<String> &testcases) {$/;"	f
unlink	pqsink.cc	/^void Evictable::unlink() {$/;"	f	class:pq::Evictable
unparse	pqjoin.cc	/^String Join::unparse() const {$/;"	f	class:pq::Join
unparse	pqjoin.cc	/^String Pattern::unparse() const {$/;"	f	class:pq::Pattern
unparse_context	pqjoin.cc	/^Json Join::unparse_context(Str context) const {$/;"	f	class:pq::Join
unparse_json	pqjoin.cc	/^Json Join::unparse_json() const {$/;"	f	class:pq::Join
unparse_json	pqjoin.cc	/^Json Pattern::unparse_json() const {$/;"	f	class:pq::Pattern
unparse_match	pqjoin.cc	/^Json Join::unparse_match(const Match& m) const {$/;"	f	class:pq::Join
update	pqsink.cc	/^bool Sink::update(Str first, Str last, Server& server,$/;"	f	class:pq::Sink
update_hint	pqsink.hh	/^inline void Sink::update_hint(const ServerStore& store, ServerStore::iterator hint) const {$/;"	f	class:pq::Sink
update_iu	pqsink.cc	/^bool Sink::update_iu(Str first, Str last, IntermediateUpdate* iu, bool& remaining,$/;"	f	class:pq::Sink
updates_	pqsink.hh	/^    interval_tree<IntermediateUpdate> updates_;$/;"	m	class:pq::Sink
valid	pqdatum.hh	/^inline bool Datum::valid() const {$/;"	f	class:pq::Datum
valid	pqsink.hh	/^inline bool Sink::valid() const {$/;"	f	class:pq::Sink
valid	pqsink.hh	/^inline bool SinkRange::valid(uint64_t now) const {$/;"	f	class:pq::SinkRange
valid_	pqsink.hh	/^    bool valid_;$/;"	m	class:pq::Sink
validate	pqsink.cc	/^bool Sink::validate(Str first, Str last, Server& server,$/;"	f	class:pq::Sink
validate	pqsink.cc	/^bool SinkRange::validate(Str first, Str last, Server& server,$/;"	f	class:pq::SinkRange
validate_args	pqsink.cc	/^    validate_args(Str first, Str last, Server& server_, uint64_t now_,$/;"	f	struct:pq::SinkRange::validate_args
validate_args	pqsink.cc	/^struct SinkRange::validate_args {$/;"	s	class:pq::SinkRange	file:
validate_filters	pqsink.cc	/^bool SinkRange::validate_filters(validate_args& va) {$/;"	f	class:pq::SinkRange
validate_step	pqsink.cc	/^bool SinkRange::validate_step(validate_args& va, int joinpos) {$/;"	f	class:pq::SinkRange
validating_	pqsink.hh	/^    bool validating_;$/;"	m	class:pq::Sink
value	pqdatum.hh	/^inline String& Datum::value() {$/;"	f	class:pq::Datum
value	pqdatum.hh	/^inline const String& Datum::value() const {$/;"	f	class:pq::Datum
value_	pqdatum.hh	/^    String value_;$/;"	m	class:pq::Datum
value_type	pqmemory.hh	/^    typedef T           value_type;$/;"	t	class:pq::Allocator
waiting_	pqsink.hh	/^    std::list<tamer::event<>> waiting_;$/;"	m	class:pq::Loadable
write_context	pqjoin.hh	/^inline void Join::write_context(uint8_t* s, const Match& m, unsigned mask) const {$/;"	f	class:pq::Join
write_json	pqlog.hh	/^inline void Log::write_json(std::ostream& s) const {$/;"	f	class:pq::Log
~Evictable	pqsink.cc	/^Evictable::~Evictable() {$/;"	f	class:pq::Evictable
~Loadable	pqsink.cc	/^Loadable::~Loadable() {$/;"	f	class:pq::Loadable
~RemoteSink	pqsink.cc	/^RemoteSink::~RemoteSink() {$/;"	f	class:pq::RemoteSink
~Sink	pqsink.cc	/^Sink::~Sink() {$/;"	f	class:pq::Sink
~SinkRange	pqsink.cc	/^SinkRange::~SinkRange() {$/;"	f	class:pq::SinkRange
